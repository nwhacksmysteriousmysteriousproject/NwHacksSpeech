import { ReplayableAudioNode } from "../common.browser/Exports";
import { IEventSource, PlatformEvent, Promise } from "../common/Exports";
import { SpeechRecognitionEvent } from "./RecognitionEvents";
export declare class RequestSession {
    private privIsDisposed;
    private privServiceTelemetryListener;
    private privDetachables;
    private privRequestId;
    private privAudioSourceId;
    private privAudioNodeId;
    private privAudioNode;
    private privAuthFetchEventId;
    private privIsAudioNodeDetached;
    private privIsCompleted;
    private privRequestCompletionDeferral;
    private privIsSpeechEnded;
    private privIsCanceled;
    private privContextJson;
    private privTurnStartAudioOffset;
    private privLastRecoOffset;
    protected privSessionId: string;
    constructor(audioSourceId: string, contextJson: string);
    readonly contextJson: string;
    readonly sessionId: string;
    readonly requestId: string;
    readonly audioNodeId: string;
    readonly completionPromise: Promise<boolean>;
    readonly isSpeechEnded: boolean;
    readonly isCompleted: boolean;
    readonly isCanceled: boolean;
    readonly currentTurnAudioOffset: number;
    listenForServiceTelemetry(eventSource: IEventSource<PlatformEvent>): void;
    onAudioSourceAttachCompleted: (audioNode: ReplayableAudioNode, isError: boolean, error?: string) => void;
    onPreConnectionStart: (authFetchEventId: string, connectionId: string) => void;
    onAuthCompleted: (isError: boolean, error?: string) => void;
    onConnectionEstablishCompleted: (statusCode: number, reason?: string) => void;
    onServiceTurnEndResponse: (continuousRecognition: boolean) => void;
    onServiceRecognized(offset: number): void;
    dispose: (error?: string) => void;
    getTelemetry: () => string;
    onCancelled(): void;
    onSpeechEnded(): void;
    protected onEvent: (event: SpeechRecognitionEvent) => void;
    private onComplete;
    private detachAudioNode;
}
